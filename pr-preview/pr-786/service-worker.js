"use strict";const CACHE="precache",broadcast=new BroadcastChannel("/api/drive.v1");let enableCache=!1;function onInstall(e){self.skipWaiting(),e.waitUntil(cacheAll())}function onActivate(e){const a=new URL(location.href).searchParams;enableCache="true"===a.get("enableCache"),e.waitUntil(self.clients.claim())}async function onFetch(e){const{request:a}=e,t=new URL(e.request.url);if("/api/service-worker-heartbeat"===t.pathname)return void e.respondWith(new Response("ok"));let n=null;shouldBroadcast(t)?n=broadcastOne(a):shouldDrop(a,t)||(n=maybeFromCache(e)),n&&e.respondWith(n)}async function maybeFromCache(e){const{request:a}=e;if(!enableCache)return await fetch(a);let t=await fromCache(a);return t?e.waitUntil(refetch(a)):(t=await fetch(a),e.waitUntil(updateCache(a,t.clone()))),t}async function fromCache(e){const a=await openCache(),t=await a.match(e);return t&&404!==t.status?t:null}async function refetch(e){const a=await fetch(e);return await updateCache(e,a),a}function shouldBroadcast(e){return e.origin===location.origin&&e.pathname.includes("/api/drive")}function shouldDrop(e,a){return"GET"!==e.method||null===a.origin.match(/^http/)||a.pathname.includes("/api/")}async function broadcastOne(e){const a=new Promise((e=>{broadcast.onmessage=a=>{e(new Response(JSON.stringify(a.data)))}})),t=await e.json();return t.receiver="broadcast.ts",broadcast.postMessage(t),await a}async function openCache(){return await caches.open(CACHE)}async function updateCache(e,a){return(await openCache()).put(e,a)}async function cacheAll(){const e=await openCache();return await e.addAll([])}self.addEventListener("install",onInstall),self.addEventListener("activate",onActivate),self.addEventListener("fetch",onFetch);